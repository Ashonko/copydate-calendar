/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CopyDatePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// calendar-view.ts
var import_obsidian = require("obsidian");
var CALENDAR_VIEW_TYPE = "copydate-calendar-view";
var CalendarView = class extends import_obsidian.ItemView {
  constructor(leaf, settings) {
    super(leaf);
    this.settings = settings;
    this.currentDate = (0, import_obsidian.moment)();
  }
  getViewType() {
    return CALENDAR_VIEW_TYPE;
  }
  getDisplayText() {
    return "Calendar";
  }
  getIcon() {
    return "calendar-days";
  }
  async onOpen() {
    this.renderCalendar();
  }
  async onClose() {
  }
  updateSettings(settings) {
    this.settings = settings;
    this.renderCalendar();
  }
  renderCalendar() {
    const container = this.contentEl;
    container.empty();
    container.addClass("copydate-view");
    const titleEl = container.createEl("div", { text: "Select Date", cls: "copydate-title" });
    const navEl = container.createEl("div", { cls: "copydate-nav" });
    const prevButton = navEl.createEl("button", { text: "\u2039", cls: "copydate-nav-btn" });
    prevButton.addEventListener("click", () => {
      this.currentDate.subtract(1, "month");
      this.renderCalendar();
    });
    const monthYearEl = navEl.createEl("span", {
      text: this.currentDate.format("MMMM YYYY"),
      cls: "copydate-month-year"
    });
    const nextButton = navEl.createEl("button", { text: "\u203A", cls: "copydate-nav-btn" });
    nextButton.addEventListener("click", () => {
      this.currentDate.add(1, "month");
      this.renderCalendar();
    });
    const calendarEl = container.createEl("div", { cls: "copydate-calendar" });
    const dayHeaders = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    const headerRow = calendarEl.createEl("div", { cls: "copydate-day-headers" });
    dayHeaders.forEach((day) => {
      headerRow.createEl("div", { text: day, cls: "copydate-day-header" });
    });
    this.renderCalendarDays(calendarEl);
    const todayButton = container.createEl("button", { text: "Today", cls: "copydate-today-btn" });
    todayButton.addEventListener("click", () => {
      this.selectDate((0, import_obsidian.moment)());
    });
    this.renderFormatDisplay(container);
  }
  renderCalendarDays(calendarEl) {
    const startOfMonth = this.currentDate.clone().startOf("month");
    const endOfMonth = this.currentDate.clone().endOf("month");
    const startDate = startOfMonth.clone().startOf("week");
    const endDate = endOfMonth.clone().endOf("week");
    const current = startDate.clone();
    const today = (0, import_obsidian.moment)();
    const daysContainer = calendarEl.createEl("div", { cls: "copydate-days" });
    while (current.isSameOrBefore(endDate, "day")) {
      const dayEl = daysContainer.createEl("div", {
        text: current.format("D"),
        cls: "copydate-day"
      });
      if (!current.isSame(this.currentDate, "month")) {
        dayEl.addClass("copydate-day-other-month");
      }
      if (current.isSame(today, "day")) {
        dayEl.addClass("copydate-day-today");
      }
      const dateToSelect = current.clone();
      dayEl.addEventListener("click", () => {
        this.selectDate(dateToSelect);
      });
      current.add(1, "day");
    }
  }
  renderFormatDisplay(container) {
    const formatContainer = container.createEl("div", { cls: "copydate-format-display" });
    const formatLabel = formatContainer.createEl("div", {
      text: "Format:",
      cls: "copydate-format-label"
    });
    let displayFormat = this.settings.dateFormat;
    if (displayFormat === "custom") {
      displayFormat = this.settings.customFormat;
    }
    const formatValue = formatContainer.createEl("div", {
      text: displayFormat,
      cls: "copydate-format-value"
    });
    const boldStatus = formatContainer.createEl("div", {
      text: this.settings.useBoldFormatting ? "Bold: ON" : "Bold: OFF",
      cls: "copydate-bold-status"
    });
  }
  selectDate(selectedDate) {
    let format = this.settings.dateFormat;
    if (format === "custom") {
      format = this.settings.customFormat;
    }
    try {
      const formattedDate = selectedDate.format(format);
      const finalText = this.settings.useBoldFormatting ? `**${formattedDate}**` : formattedDate;
      this.insertDateAtCursor(finalText);
    } catch (error) {
      console.error("Error formatting date:", error);
      const fallbackDate = selectedDate.format("YYYY-MM-DD");
      const finalText = this.settings.useBoldFormatting ? `**${fallbackDate}**` : fallbackDate;
      this.insertDateAtCursor(finalText);
    }
  }
  insertDateAtCursor(formattedDate) {
    const { workspace } = this.app;
    const activeView = workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView && activeView.editor) {
      const editor = activeView.editor;
      const cursor = editor.getCursor();
      editor.replaceRange(formattedDate, cursor);
      const newCursor = {
        line: cursor.line,
        ch: cursor.ch + formattedDate.length
      };
      editor.setCursor(newCursor);
      editor.focus();
      return;
    }
    const activeFile = workspace.getActiveFile();
    if (activeFile) {
      const markdownLeaves2 = workspace.getLeavesOfType("markdown");
      for (const leaf of markdownLeaves2) {
        const view = leaf.view;
        if (view && view.file === activeFile && view.editor) {
          const editor = view.editor;
          const cursor = editor.getCursor();
          editor.replaceRange(formattedDate, cursor);
          const newCursor = {
            line: cursor.line,
            ch: cursor.ch + formattedDate.length
          };
          editor.setCursor(newCursor);
          workspace.setActiveLeaf(leaf);
          editor.focus();
          return;
        }
      }
    }
    const markdownLeaves = workspace.getLeavesOfType("markdown");
    if (markdownLeaves.length > 0) {
      const activeLeaf = workspace.activeLeaf;
      if (activeLeaf && activeLeaf.view instanceof import_obsidian.MarkdownView) {
        const view2 = activeLeaf.view;
        if (view2.editor) {
          const editor = view2.editor;
          const cursor = editor.getCursor();
          editor.replaceRange(formattedDate, cursor);
          const newCursor = {
            line: cursor.line,
            ch: cursor.ch + formattedDate.length
          };
          editor.setCursor(newCursor);
          editor.focus();
          return;
        }
      }
      let bestLeaf = markdownLeaves[0];
      for (const leaf of markdownLeaves) {
        const view2 = leaf.view;
        if (view2 && view2.editor) {
          try {
            const editor = view2.editor;
            const cursor = editor.getCursor();
            if (cursor) {
              bestLeaf = leaf;
              break;
            }
          } catch (e) {
          }
        }
      }
      const view = bestLeaf.view;
      if (view && view.editor) {
        const editor = view.editor;
        const cursor = editor.getCursor();
        editor.replaceRange(formattedDate, cursor);
        const newCursor = {
          line: cursor.line,
          ch: cursor.ch + formattedDate.length
        };
        editor.setCursor(newCursor);
        workspace.setActiveLeaf(bestLeaf);
        editor.focus();
        return;
      }
    }
    console.warn("No active markdown view found. Please open a note first.");
    const notice = document.createElement("div");
    notice.textContent = "Please open a note first to insert the date";
    notice.className = "copydate-notice";
    document.body.appendChild(notice);
    setTimeout(() => {
      if (notice.parentNode) {
        notice.parentNode.removeChild(notice);
      }
    }, 3e3);
  }
};

// settings.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  dateFormat: "YYYY-MM-DD",
  useBoldFormatting: true,
  customFormat: "YYYY-MM-DD"
};
var DATE_FORMAT_OPTIONS = [
  { value: "YYYY-MM-DD", label: "YYYY-MM-DD (e.g., 2025-01-25)" },
  { value: "DD-MM-YYYY", label: "DD-MM-YYYY (e.g., 25-01-2025)" },
  { value: "DD/MM/YYYY", label: "DD/MM/YYYY (e.g., 25/01/2025)" },
  { value: "MM/DD/YYYY", label: "MM/DD/YYYY (e.g., 01/25/2025)" },
  { value: "MMMM DD, YYYY", label: "MMMM DD, YYYY (e.g., January 25, 2025)" },
  { value: "DD MMMM YYYY", label: "DD MMMM YYYY (e.g., 25 January 2025)" },
  { value: "custom", label: "Custom format" }
];
var CopyDateSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("CopyDate Calendar Settings").setHeading();
    new import_obsidian2.Setting(containerEl).setName("Date format").setDesc("Choose how dates should be formatted when inserted").addDropdown((dropdown) => {
      DATE_FORMAT_OPTIONS.forEach((option) => {
        dropdown.addOption(option.value, option.label);
      });
      dropdown.setValue(this.plugin.settings.dateFormat);
      dropdown.onChange(async (value) => {
        this.plugin.settings.dateFormat = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (this.plugin.settings.dateFormat === "custom") {
      new import_obsidian2.Setting(containerEl).setName("Custom date format").setDesc("Use moment.js format tokens (e.g., YYYY-MM-DD, DD/MM/YY, etc.)").addText((text) => text.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.customFormat).onChange(async (value) => {
        this.plugin.settings.customFormat = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian2.Setting(containerEl).setName("Bold formatting").setDesc("Wrap inserted dates with ** to make them bold").addToggle((toggle) => toggle.setValue(this.plugin.settings.useBoldFormatting).onChange(async (value) => {
      this.plugin.settings.useBoldFormatting = value;
      await this.plugin.saveSettings();
      const previewContainer2 = containerEl.querySelector(".copydate-preview");
      if (previewContainer2) {
        this.updatePreview(previewContainer2);
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Preview").setHeading();
    const previewContainer = containerEl.createDiv("copydate-preview");
    this.updatePreview(previewContainer);
  }
  updatePreview(container) {
    container.empty();
    const today = new Date();
    let format = this.plugin.settings.dateFormat;
    if (format === "custom") {
      format = this.plugin.settings.customFormat;
    }
    try {
      const formattedDate = (0, import_obsidian2.moment)(today).format(format);
      const finalText = this.plugin.settings.useBoldFormatting ? `**${formattedDate}**` : formattedDate;
      const previewEl = container.createEl("div", { cls: "copydate-preview-text" });
      previewEl.textContent = `Preview: ${finalText}`;
    } catch (error) {
      const previewEl = container.createEl("div", { cls: "copydate-preview-error" });
      previewEl.textContent = "Invalid format";
    }
  }
};

// main.ts
var CopyDatePlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerView(
      CALENDAR_VIEW_TYPE,
      (leaf) => new CalendarView(leaf, this.settings)
    );
    const ribbonIconEl = this.addRibbonIcon("calendar-days", "Open Calendar", (evt) => {
      this.activateView();
    });
    ribbonIconEl.addClass("copydate-ribbon-class");
    this.addSettingTab(new CopyDateSettingsTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateAllCalendarViews();
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(CALENDAR_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: CALENDAR_VIEW_TYPE, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  updateAllCalendarViews() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(CALENDAR_VIEW_TYPE);
    leaves.forEach((leaf) => {
      const view = leaf.view;
      if (view && view.updateSettings) {
        view.updateSettings(this.settings);
      }
    });
  }
};
